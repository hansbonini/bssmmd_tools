
<head>
<meta http-equiv="Content-Language" content="en-us">
</head>

<body bgcolor="#FFFFFF">

<p align="center"><u><b><font size="7">KENS</font></b></u></p>
<p align="center">Kosinski / Enigma / Nemesis / Saxman Compression and Decompression Libraries<br>
Copyright  2002-2012 The KENS Project Development Team</p>
<p align="left">&nbsp;</p>
<p align="left"><a href="#1_Intro">1. What is KENS ?</a><br>
<a href="#2_Authors">2. Who made KENS ?</a><br>
<a href="#3_CPlusPlus">3. How do I use KENS in a C/C++ program ?</a><br>
<a href="#4_Delphi">4. How do I use KENS in a Delphi program ?</a><br>
<a href="#5_VisualBasic">5. How do I use KENS in a Visual Basic program ?</a><br>
<a href="#6_GameMaker">6. How do I use KENS in a Game Maker &quot;program&quot; ?</a><br>
<a href="#7_Functions">7. What are the functions, and how do I call them&nbsp; ?</a><br>
<a href="#8_Buffer">8. Advanced topic: How do I decompress to a buffer rather than a file ?</a><br>
<a href="#9_Streams">9. Advanced topic: How do I decompress to a stream rather than a file ?</a></p>
<p align="left">&nbsp;</p>
<p align="left"><b><u><a name="1_Intro"></a>1. What is KENS ?</u></b></p>
<p align="left">KENS is a group of four libraries that allow you to compress and 
decompress data using the Kosinski, Enigma, Nemesis and Saxman compression 
formats. These libraries, programmed using Visual C++, can be easily used from 
your applications, even from Visual Basic and Game Maker applications. KENS is 
being distributed under GPL. For more info about the GPL, read 
<a href="LICENSE.HTML">LICENSE.htm</a>.</p>
<p align="left">&nbsp;</p>
<p align="left"><u><b><a name="2_Authors"></a>2. Who made KENS ?</b></u></p>
<p align="left">Several people worked on KENS, in a way or another. There are 
people who cracked the formats, others who wrote the algorithms to compress and 
decompress the data, some who contributed by making headers allowing to use the 
libraries easily in other programming languages, and people who tested them heavily and reported bugs. All these people can be considered to be a part of a 
team, The KENS Project Development Team. Without them, making KENS what it has 
become today would not have been possible. Here is a list of these people so far 
(in alphabetical order).<br>
&nbsp;<div align="center">
<table border="0" id="table1" width="414">
	<tr>
		<td>Brett Kosinski</td>
		<td width="200">brettk@gpu.srv.ualberta.ca</td>
	</tr>
	<tr>
		<td>Damian &quot;Saxman&quot; Grove</td>
		<td width="200">saxman@shentel.net</td>
	</tr>
	<tr>
		<td>David &quot;Magus&quot; Declerck</td>
		<td width="200">ChaosIsLight@aol.com</td>
	</tr>
	<tr>
		<td>Korama</td>
		<td width="200">amarokorama@msn.com</td>
	</tr>
	<tr>
		<td>Mark "kramlat" Toman</td>
		<td width="200">kram1024@hotmail.com</td>
	</tr>
	<tr>
		<td>Roger &quot;Nemesis&quot; Sanders</td>
		<td width="200">nemesis2k2hacker@hotmail.com</td>
	</tr>
	<tr>
		<td>Stealth</td>
		<td width="200">stealth@emulationzone.org</td>
	</tr>
	<tr>
		<td>Ultima</td>
		<td width="200">ultima@shadowsoft-games.com</td>
	</tr>
	<tr>
		<td>Flamewing</td>
		<td width="200">(not yet added here)</td>
	</tr>
</table>
	<p align="left">&nbsp;</p>
	<p align="left"><u><b><a name="3_CPlusPlus"></a>3. How do I use KENS in a C/C++ program ?</b></u></div>
<p align="left">Include the kosinski.h, enigma.h, nemesis.h or saxman.h files 
into any file that calls the compression / decompression routines. 
Alternatively, you can just include kens.h, which contains the definitions of 
all these four files or advanced c++ routines that are impossible to fit in the individual headers. 
These functions all take a parameter that specifies the path to the library, and they return &quot;true&quot;
if initialization worked or &quot;false&quot; if it 
didn't. It is very important that you check the return value of these functions 
before calling any of the functions from the library.</p>
<p align="left">&nbsp;</p>
<div align="center">
	<p align="left"><u><b><a name="4_Delphi"></a>4. How do I use KENS in a Delphi program ?</b></u></p>
<p align="left">Delphi support is not yet in the new engine, it will eventually return before 1.5 becomes stable though.</p>
<p align="left">&nbsp;</p>
<p align="left"><u><b><a name="5_VisualBasic"></a>5. How do I use KENS in a Visual Basic program ?</b></u></p>
<p align="left">Visual Basic support is not in the new engine yet, but we will have both classic visual basic support and .Net in the stable 1.5 version.</p>
<p align="left">&nbsp;</p>
<p align="left"><u><b><a name="6_GameMaker"></a>6. How do I use KENS in a Game Maker &quot;program&quot; ?</b></u></p>
<p align="left">GameMaker support is not yet in this version, but expect it to show up in the stable 1.5 version</p>
<p align="left"><u><b><a name="8_Buffer"></a>8. Advanced topic: How do I decompress to a buffer rather than a file ?</b></u></p>
<p align="left">Since version 1.4, it is now possible to decompress data to a 
buffer rather than a file. However, there is a requirement. You must be using a 
programming language that is capable of using pointers and calling the standard functions from the 
DLLs. This means you won't be able to decompress to a buffer under Visual Basic 
or Game Maker. However, you will be able to do it under C/C++ and Delphi. In 
order to do so, you will have to use the following functions:<br>
Kosinski: KCompToBuf, KDecompToBuf and KCompExToBuf<br>
Enigma: ECompToBuf and EDecompToBuf<br>
Nemesis: NCompToBuf and NDecompToBuf<br>
Saxman: SCompToBuf and SDecompToBuf<br>

These functions are practically identical to the classic functions. There are 
only two differences. The second parameter, instead of being a string that contains 
the name of the destination file, is a pointer to the destination buffer (this 
pointer being passed by reference). This buffer must be 
declared as char* or char[] in C/C++ or Pointer in Delphi. Also, right after 
this parameter, a new parameter was inserted. It is a pointer to a long that 
will receive the size of the data contained in the buffer. This parameter MUST 
be specified correctly (don't pass NULL). The rest of the parameters remains unchanged.<br>
Now, here are the two ways 
of calling these functions.<br>
* If you specify a NULL pointer as the destination buffer (a pointer set to NULL or 0), the function will 
initialize it by itself and fill the buffer with the output data. The advantage 
is that the buffer will be initialized to the right size. However you will have 
to call the FreeBuffer() function from the KENS DLL and pass the pointer to the 
buffer as a parameter in order to free it. Note that if you are using C++, you 
may free it by yourself by calling the delete[] operator. Do NOT try to use the 
ANSI-C free() function on the pointer.<br>
* If you specify an already initialized pointer, the function will simply fill 
the buffer with the output data. You should ensure that the buffer is large 
enough to handle the data it will receive, otherwise you'll get an access 
violation error. You also have to free the pointer by yourself.</p>
<p align="left"><u><b><a name="9_Streams"></a>9. Advanced topic: How do I decompress to a stream rather than a file ?</b></u></p>
<p align="left">Since version 1.5, it is now possible to decompress data to a 
stream rather than a file. However, there is a requirement. You must be using a 
programming language that is capable of using streams and calling the standard functions from the 
DLLs. This means you won't be able to decompress to a buffer under Visual Basic 
or Game Maker. However, you will be able to do it under C/C++ and (soon) Delphi. In 
order to do so, you will have to use the following functions:<br>
Kosinski: use kosinski::encode and kosinski::decode <br>
Enigma: use enigma::encode and enigma::decode<br>
Nemesis: use nemesis::encode and nemesis::decode<br>
Saxman: not yet functional, expect working in stable release<br>

These functions are practically identical to the classic functions. The difference is that, instead of using filenames, 
iostreams are used instead. The source must be compatible with a std::istream and the destination with a std::ostream. 
<br>
all the above seem to work as sources and destinations:
* std::istream
* std::ostream
* std::fstream
* std::ifstream
* std::stringstream
and the streams will act like buffers and files, they may or may not be connected with a file, but yet function sorta like one and no temp files are needed.
</p>
<p align="left">&nbsp;</p>
<p align="left">&nbsp;</p>
<p align="left">&nbsp;</p>
<p align="left">&nbsp;</p>
<p align="left">&nbsp;</p>
<p align="left">&nbsp;</p>
</body>
